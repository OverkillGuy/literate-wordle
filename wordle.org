#+TITLE: Wordle

# Shell steps should show results verbatim (not tables) and don't rerun on export
#+PROPERTY: header-args:shell :results verbatim :eval no-export

Implementing the viral game "Wordle" in Python using literate programming!

Literate programming is the art of writing code as if it was a novel (or
blogpost), writing down what's needed, explaining the reasoning, and weaving in
code snippets that add up to the codebase as we grow in understanding. The
result is a "story" which can be read, but also "tangled" back into a proper
codebase that works normally.

I'll be making liberal use of Gherkin to describe what we're building.

* Mise en bouche: picking an answer

To get us started, let's cover the very first thing Wordle has to do: pick a
word that will become our answer:

#+CAPTION: Our first requirement
#+begin_src feature :tangle features/pick_answer_word.feature
Feature: Pick an answer word
  As a Wordle game
  I need to pick a random 5 letter word
  In order to let players guess it
#+end_src

Right. That's fairly straightforward, but the secret word can't be random
characters, it needs to be a proper word. So we need to find a dictionary to
pick from.
** Solution dictionary file
Since we're trying to match the Wordle website, let's use Wordle's own
dictionary. Someone [[https://raw.githubusercontent.com/AllValley/WordleDictionary/main/wordle_solutions_alphabetized.txt][helpfully uploaded it]]. We'll need to download it locally
first:

#+begin_src shell :tangle no
wget \
    --output-document "src/literate_wordle/assets/wordle_answers_dict.txt" \
    "https://raw.githubusercontent.com/AllValley/WordleDictionary/6f14d2f03d01c36fe66e3ccc0929394251ab139d/wordle_solutions_alphabetized.txt"
#+end_src

#+RESULTS:

Except an alphabetically sorted text file takes a lot of space but compresses
really well: let's compress that instead

#+begin_src shell :tangle no :exports both
ANSWERS_FILE="src/literate_wordle/assets/wordle_answers_dict.txt"
du -k "${ANSWERS_FILE}"
gzip "$ANSWERS_FILE"
du -k "${ANSWERS_FILE}.gz"
# Unnecessary: gzip removes the original as it compresses
# rm "$ANSWERS_FILE"
#+end_src

#+RESULTS:
: 16	src/literate_wordle/assets/wordle_answers_dict.txt
: 8	src/literate_wordle/assets/wordle_answers_dict.txt.gz

Sweet, we have cut down the filesize by half.

Now, let's use Test-Driven Development to guide us towards picking an answer
word.

** TDD for picking word functionality

#+begin_src python :tangle tests/test_pick_word.py
"""Validates the Gherkin file features/pick_answer_word.feature:

Feature: Pick an answer word
  As a Wordle game
  I need to pick a random 5 letter word
  In order to let players guess it
"""

from literate_wordle.words import pick_answer_word


def test_pick_word_ok_length():
    """Confirm a wordle solution is of right size"""
    assert len(pick_answer_word()) == 5, "Picked wordle solution is wrong size!"
#+end_src

Of course, since that feature isn't implemented (not even the skeleton), running
tests right now would crash, not just give a red light. So let's implement the
barest hint of a function that returns the wrong thing, to make the test run but
fail:

First, the docstring for a new python module =words.py=

#+begin_src python :tangle no
"""Dictionary features to back wordle solutions"""
#+end_src

In that module, let's add the skeleton for our =pick_answer_word= function, but
return an invalid result, to make test explicitly fail:

#+begin_src python :tangle no
def pick_answer_word() -> str:
    """Pick a Wordle solution/answer from wordle dictionary"""
    return ""  # Incorrect solution to get RED test
#+end_src

With our test ready, and a dummy function in place, let's see the tests go red:

#+CAPTION: Running the tests. Note the redirection of errors to make them register and visible in my notes
#+begin_src shell :exports both
make test 2>&1 || true
#+end_src

#+RESULTS:
#+begin_example
poetry run pytest
============================= test session starts ==============================
platform linux -- Python 3.9.5, pytest-6.2.5, py-1.11.0, pluggy-1.0.0 -- /home/jiby/dev/ws/short/literate_wordle/.venv/bin/python
cachedir: .pytest_cache
rootdir: /home/jiby/dev/ws/short/literate_wordle, configfile: pyproject.toml
plugins: cov-3.0.0, datadir-1.3.1, clarity-1.0.1
collecting ... collected 2 items

tests/test_pick_word.py::test_pick_word_ok_length FAILED                 [ 50%]
tests/test_version.py::test_version PASSED                               [100%]

=================================== FAILURES ===================================
___________________________ test_pick_word_ok_length ___________________________

    def test_pick_word_ok_length():
        """Confirm a wordle solution is of right size"""
>       assert len(pick_answer_word()) == 5, "Picked wordle solution is wrong size!"
E       AssertionError: Picked wordle solution is wrong size!
E       assert == failed. [pytest-clarity diff shown]
E
E         LHS vs RHS shown below
E
E         0
E         5
E

tests/test_pick_word.py:13: AssertionError
- generated xml file: /home/jiby/dev/ws/short/literate_wordle/test_results/results.xml -
=========================== short test summary info ============================
FAILED tests/test_pick_word.py::test_pick_word_ok_length - AssertionError: Pi...
========================= 1 failed, 1 passed in 0.07s ==========================
make: *** [Makefile:16: test] Error 1
#+end_example

Tests indeed failed as expected, can now try to make it pass.

** Importing dictionary: static/packaged asset file read

At first glance, the implementation of the function we want is simple, it looks
roughly like this:

#+begin_src python :tangle no
with open("my_dictionary.txt", "r") as fd:
    my_text = fd.read()
#+end_src

One just needs to find the right file path and we're done, just add sprinkles to
deal with compression. Sure enough, that is fairly easy.

The issue is that we're trying to write a python package here, which means it could
be downloaded via =pip install= and installed in an arbitary location on
someone's computer , so our code needs to say "the file that is in my package
alongside me", which is a little more complex.

From [[https://stackoverflow.com/a/20885799][Stackoverflow on reading static files from inside Python package]], we can
use the =importlib.resources= module, since our project requires =Python >3.8=.

So let's define first a =get_words_list= function to wrap around the import
weirdness:

#+begin_src python :tangle src/literate_wordle/words.py
"""Dictionary features to back wordle solutions"""
#+end_src

#+NAME: choice-stdlib
#+CAPTION: Necessary standard library imports
#+begin_src python :tangle no
import gzip
import importlib.resources as pkg_resources
#+end_src

#+NAME: choice-stdlib2
#+begin_src python :tangle no
from random import choice
#+end_src

#+NAME: choice-locallib
#+CAPTION: Local import of =assets/= folder
#+begin_src python :tangle no
from . import assets  # Relative import of the assets/ folder
#+end_src

#+NAME: choice-func-unzipdict
#+CAPTION: Actual function to unzip dictionary
#+begin_src python :tangle no
def get_words_list() -> list[str]:
    """Decompress the wordle dictionary"""
    dict_compressed_bytes = pkg_resources.read_binary(
        assets, "wordle_answers_dict.txt.gz"
    )
    dict_string = gzip.decompress(dict_compressed_bytes).decode("ascii")
    answer_word_list = [word.strip().lower() for word in dict_string.split("\n")]
    return answer_word_list
#+end_src

Then write out the pretty trivial function to pick:

#+NAME: choice-func-pickanswer
#+CAPTION: Pick-a-word!
#+begin_src python :tangle no
def pick_answer_word() -> str:
    """Pick a single word out of the dictionary of answers"""
    return choice(get_words_list())
#+end_src

And make the =assets/= folder a proper importable python module just to be sure

#+begin_src shell :tangle no :exports code
echo '"""Static binary assets required to Wordle well"""' > src/literate_wordle/assets/__init__.py
#+end_src

... So now we have an implementation of the function, let's manually test it in
a Python REPL:

#+begin_src shell :tangle no :exports both
poetry run python3 -c 'from literate_wordle import words; print(words.pick_answer_word()); print(words.pick_answer_word())'
#+end_src

#+RESULTS:
: stink
: blank

Perfect! So the test should now pass, right?

#+begin_src shell :tangle no :exports both
make
#+end_src

#+RESULTS:
#+begin_example
poetry install
Installing dependencies from lock file

No dependencies to install or update

Installing the current project: literate_wordle (0.1.0)
pre-commit run --all --all-files
Emacs tangle org-mode literate-programming files (ensures synced).......................Passed
Emacs export org-mode file to static HTML...............................................Passed
Trim Trailing Whitespace................................................................Passed
Fix End of Files........................................................................Passed
Check for added large files.............................................................Passed
Check that executables have shebangs................................(no files to check)Skipped
Check for case conflicts................................................................Passed
Check vcs permalinks....................................................................Passed
Forbid new submodules...................................................................Passed
Mixed line ending.......................................................................Passed
Check for merge conflicts...............................................................Passed
Detect Private Key......................................................................Passed
Check Toml..............................................................................Passed
Check Yaml..............................................................................Passed
Check JSON..........................................................(no files to check)Skipped
mypy....................................................................................Passed
cd docs && make html
make[1]: Entering directory '/home/jiby/dev/ws/short/literate_wordle/docs'
Running Sphinx v4.4.0
Read in collections ...
  wordle_html_export_filecopy: Initialised
  gherkin_features_foldercopy: Initialised
  gherkin_features_jinja: Initialised
Clean collections ...
  gherkin_features_foldercopy: (CopyFolderDriver) Folder deleted: /home/jiby/dev/ws/short/literate_wordle/docs/source/_collections/gherkin_features/
  gherkin_features_jinja: (JinjaDriver) Cleaning 1 jinja Based file/s ...
Executing collections ...
  wordle_html_export_filecopy: (CopyFileDriver) Copy file...
  gherkin_features_foldercopy: (CopyFolderDriver) Copy folder...
  gherkin_features_jinja: (JinjaDriver) Creating 1 file/s from Jinja template...
loading pickled environment... done
[autosummary] generating autosummary for: _collections/gherkin_feature.md, index.rst, readme.md, wordle.md
[AutoAPI] Reading files... [ 33%] /home/jiby/dev/ws/short/literate_wordle/src/literate_wordle/__init__.py
[AutoAPI] Reading files... [ 66%] /home/jiby/dev/ws/short/literate_wordle/src/literate_wordle/words.py
[AutoAPI] Reading files... [100%] /home/jiby/dev/ws/short/literate_wordle/src/literate_wordle/assets/__init__.py

[AutoAPI] Mapping Data... [ 33%] /home/jiby/dev/ws/short/literate_wordle/src/literate_wordle/__init__.py
[AutoAPI] Mapping Data... [ 66%] /home/jiby/dev/ws/short/literate_wordle/src/literate_wordle/words.py
[AutoAPI] Mapping Data... [100%] /home/jiby/dev/ws/short/literate_wordle/src/literate_wordle/assets/__init__.py

[AutoAPI] Rendering Data... [ 33%] literate_wordle
[AutoAPI] Rendering Data... [ 66%] literate_wordle.words
[AutoAPI] Rendering Data... [100%] literate_wordle.assets

myst v0.15.2: MdParserConfig(renderer='sphinx', commonmark_only=False, enable_extensions=['dollarmath'], dmath_allow_labels=True, dmath_allow_space=True, dmath_allow_digits=True, dmath_double_inline=False, update_mathjax=True, mathjax_classes='tex2jax_process|mathjax_process|math|output_area', disable_syntax=[], url_schemes=['http', 'https', 'mailto', 'ftp'], heading_anchors=2, heading_slug_func=None, html_meta=[], footnote_transition=True, substitutions=[], sub_delimiters=['{', '}'], words_per_minute=200)
building [mo]: targets for 0 po files that are out of date
building [html]: targets for 5 source files that are out of date
updating environment: 0 added, 6 changed, 1 removed
reading sources... [ 16%] _collections/gherkin_feature
reading sources... [ 33%] autoapi/index
reading sources... [ 50%] autoapi/literate_wordle/assets/index
reading sources... [ 66%] autoapi/literate_wordle/index
reading sources... [ 83%] autoapi/literate_wordle/words/index
reading sources... [100%] wordle

Copying static files for sphinx-needs datatables support.../home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/datatables_loader.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/datatables.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/sphinx_needs_collapse.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/datatables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/JSZip-2.5.0/jszip.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/js/buttons.print.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/js/buttons.flash.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/js/buttons.html5.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/js/buttons.colVis.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/js/dataTables.buttons.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/js/buttons.html5.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/css/common.scss /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/css/mixins.scss /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/css/buttons.dataTables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/swf/flashExport.swf /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/DataTables-1.10.16/js/jquery.dataTables.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/DataTables-1.10.16/css/jquery.dataTables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/DataTables-1.10.16/images/sort_asc.png /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/DataTables-1.10.16/images/sort_desc_disabled.png /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/DataTables-1.10.16/images/sort_asc_disabled.png /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/DataTables-1.10.16/images/sort_both.png /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/DataTables-1.10.16/images/sort_desc.png /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/ColReorder-1.4.1/js/dataTables.colReorder.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/ColReorder-1.4.1/css/colReorder.dataTables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/FixedColumns-3.2.4/js/dataTables.fixedColumns.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/FixedColumns-3.2.4/css/fixedColumns.dataTables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Scroller-1.4.4/js/dataTables.scroller.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Scroller-1.4.4/css/scroller.dataTables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/FixedHeader-3.1.3/js/dataTables.fixedHeader.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/FixedHeader-3.1.3/css/fixedHeader.dataTables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Responsive-2.2.1/js/dataTables.responsive.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Responsive-2.2.1/css/responsive.dataTables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/pdfmake-0.1.32/pdfmake.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/pdfmake-0.1.32/vfs_fonts.js
Copying static files for sphinx-needs custom style support...[ 25%] common.css
Copying static files for sphinx-needs custom style support...[ 50%] /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/css/modern/layouts.css
Copying static files for sphinx-needs custom style support...[ 75%] /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/css/modern/styles.css
Copying static files for sphinx-needs custom style support...[100%] /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/css/modern/modern.css

looking for now-outdated files... none found
pickling environment... done
checking consistency... done
preparing documents... done
writing output... [ 14%] _collections/gherkin_feature
writing output... [ 28%] autoapi/index
writing output... [ 42%] autoapi/literate_wordle/assets/index
writing output... [ 57%] autoapi/literate_wordle/index
writing output... [ 71%] autoapi/literate_wordle/words/index
writing output... [ 85%] index
writing output... [100%] wordle

generating indices... genindex py-modindex done
highlighting module code... [ 50%] literate_wordle
highlighting module code... [100%] literate_wordle.words

writing additional pages... search done
copying images... [ 50%] /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/images/feather_svg/arrow-down-circle.svg
copying images... [100%] /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/images/feather_svg/arrow-right-circle.svg

copying static files... done
copying extra files... done
dumping search index in English (code: en)... done
dumping object inventory... done
build succeeded, 2 warnings.

The HTML pages are in build/html.
Final clean of collections ...
  wordle_html_export_filecopy: (CopyFileDriver) File deleted: /home/jiby/dev/ws/short/literate_wordle/docs/source/_collections/_static/wordle.html
  gherkin_features_foldercopy: (CopyFolderDriver) Folder deleted: /home/jiby/dev/ws/short/literate_wordle/docs/source/_collections/gherkin_features/
  gherkin_features_jinja: (JinjaDriver) Cleaning 1 jinja Based file/s ...
  gherkin_features_jinja: (JinjaDriver)   File deleted: /home/jiby/dev/ws/short/literate_wordle/docs/source/_collections/gherkin_feature.md

Checking sphinx-needs warnings
make[1]: Leaving directory '/home/jiby/dev/ws/short/literate_wordle/docs'
poetry run pytest
============================= test session starts ==============================
platform linux -- Python 3.9.5, pytest-6.2.5, py-1.11.0, pluggy-1.0.0 -- /home/jiby/dev/ws/short/literate_wordle/.venv/bin/python
cachedir: .pytest_cache
rootdir: /home/jiby/dev/ws/short/literate_wordle, configfile: pyproject.toml
plugins: cov-3.0.0, datadir-1.3.1, clarity-1.0.1
collecting ... collected 2 items

tests/test_pick_word.py::test_pick_word_ok_length PASSED                 [ 50%]
tests/test_version.py::test_version PASSED                               [100%]

- generated xml file: /home/jiby/dev/ws/short/literate_wordle/test_results/results.xml -
============================== 2 passed in 0.03s ===============================
poetry build
Building literate_wordle (0.1.0)
  - Building sdist
  - Built literate_wordle-0.1.0.tar.gz
  - Building wheel
  - Built literate_wordle-0.1.0-py3-none-any.whl
#+end_example

Everything checks out: our feature is ready![fn::Keen readers will notice
sub-optimal code, such as re-unzipping the entire solutions file
before any picking of solution. Indeed, these are valid points. But in the
context of this project, these are accepted tradeoffs leaning towards
legibility/simplicity of implementation against raw performance. Considering
that "picking a solution word" is something done on the order of /once/ over the
entire runtime, we can afford it.]
** Debriefing on the method

We just completed our first loop: determine a small component that needs
implemented to build towards Wordle goal, spell it out with Gherkin features,
explicit the feature via tests, and iterate on the new RED test until it becomes
green.[fn::Usual TDD cycle adds a refactor/blue cycle, which is indeed necessary
for production code, as it lends to maintainability. This code is intended as
entertainment material, with this literate-programming article as companion.
Refactoring would mean refactoring the =wordle.org= source file, which would
drown out the nice narrative we're building here.]

Along the way, the code spelled out in this narrative-oriented file is tangled
out into proper code paths, so that the =Makefile= can pick it up and validate
the proper package-ness.
* Confirming guess is a valid word

Now that we can pick secret words, we need to start processing guesses. The very
first thing a guess needs is validating guesses are proper words of the right
length. This feature will give us a familiar context (dictionaries), while
slowly ramping up the details of the Gherkin features:

#+NAME: feature-check-valid-guess
#+CAPTION: New Gherkin feature file =features/checking_guess_valid_word.feature=
#+begin_src feature :tangle features/checking_guess_valid_word.feature
Feature: Checking a guess is a valid word
  As a Wordle game
  I need to confirm each guessed word is valid
  So that I only accept real words, no kwyjibo
#+end_src

In practice, this means multiple things:

#+NAME: scenario-check-valid-guess
#+CAPTION: Scenarios to describe the feature in details
#+begin_src feature :tangle features/checking_guess_valid_word.feature
Scenario: Reject long words
  When guessing "affable"
  Then the guess is rejected
  And reason for rejection is "Guess too long"

Scenario: Reject short words
  When guessing "baby"
  Then the guess is rejected
  And reason for rejection is "Guess too short"

Scenario: Reject fake words via dictionary
  When guessing "vbpdj"
  Then the guess is rejected
  And reason for rejection is "Not a word from the dictionary"

Scenario: Accept five letter dictionary words
  When guessing "crane"
  Then the guess is accepted
#+end_src

So, with a feature covering two scenarios, we can start laying out acceptance
tests.

Since I quite like to use the Gherkin feature file inside the
docstrings of Python tests, I'm going to take advantage of having already
written it above to reference it for export, so I can template it out:

#+CAPTION: New test file's module-level docstring, using (invisible during rendering) templating to fill in the gherkin feature from Listing [[feature-check-valid-guess]] and [[scenario-check-valid-guess]]
#+begin_src python :tangle tests/test_checking_guess_valid_word.py :noweb yes
"""Validates the Gherkin file features/checking_guess_valid_word.feature:

<<feature-check-valid-guess>>

<<scenario-check-valid-guess>>
"""
#+end_src
** Test setup
With the feature described, let's import our hypothetical test code

#+NAME: test-valid-import
#+begin_src python :tangle no
from literate_wordle.words import check_valid_word
#+end_src

And write out a simple test using the first scenario:

#+NAME: test-valid-1
#+begin_src python :tangle no
def test_reject_long_words():
    """Scenario: Reject long words"""
    # When guessing "affable"
    guess = "affable"
    is_valid, reject_reason = check_valid_word(guess)
    # Then the guess is rejected
    assert not is_valid, "Overly long guess should have been rejected"
    # And reason for rejection is "Guess too long"
    assert reject_reason == "Guess too long"
#+end_src

And in a similar way, we write the opposite test for too short:

#+NAME: test-valid-2
#+begin_src python :tangle no
def test_reject_overly_short_words():
    """Scenario: Reject short words"""
    # When guessing "baby"
    guess = "baby"
    is_valid, reject_reason = check_valid_word(guess)
    # Then the guess is rejected
    assert not is_valid, "Overly short guess should have been rejected"
    # And reason for rejection is "Guess too short"
    assert reject_reason == "Guess too short"
#+end_src

And finally, the dictionary checks:

#+NAME: test-valid-3
#+begin_src python :tangle no
def test_reject_nondict_words():
    """Scenario: Reject fake words via dictionary"""
    # When guessing "vbpdj"
    guess = "vbpdj"
    is_valid, reject_reason = check_valid_word(guess)
    # Then the guess is rejected
    assert not is_valid, "Word not in dictionary should have been rejected"
    # And reason for rejection is "Not a word from the dictionary"
    assert reject_reason == "Not a word from the dictionary"
#+end_src


#+NAME: test-valid-4
#+begin_src python :tangle no
def test_accept_dict_words():
    """Scenario: Accept five letter dictionary words"""
    # When guessing "crane"
    guess = "crane"
    is_valid, reject_reason = check_valid_word(guess)
    # Then the guess is accepted
    assert is_valid, "Correct length word in dictionary should have been accepted"
#+end_src

One tiny detail regarding this last example, which highlights why separating
Gherkin from actual code is important: We describe in the positive scenario the
need to accept a correct word in terms of "not rejecting", which in code maps to
the =is_valid= boolean. That's suffficient to make the Gherkin scenario, which
is what we think of when designing the software, but as we see in the
implementation, there's also the matter of the =reject_reason= component, which
we should check for emptiness. That is an implementation detail, which has no
reason to be laid out in the original scenario, but is still valid to make
assertions on. So we shall:

#+NAME: reject-reason-none
#+CAPTION: This line isn't defined in Gherkin, because it separates the implementation from the feature's requirement
#+begin_src python :tangle no
    assert reject_reason is None, "Accepted word should have no reason to be rejected"
#+end_src

With all these (high level) tests in hand, let's write up some small
implementation to get RED tests instead of a crash.

First up is defining a signature: We take a guess in, and return a boolean and a
string. Except sometimes (as seen in Listing [[reject-reason-none]]) it's
=None=, so that's more of an =Optional= string, which we'll need to import:

#+NAME: valid-stdlib
#+begin_src python :tangle no
from typing import Optional, Tuple
#+end_src

#+NAME: valid-func-proto
#+begin_src python :tangle no
def check_valid_word(guess: str) -> Tuple[bool, Optional[str]]:
#+end_src

And to fill it with junk:

#+NAME: valid-func-junk
#+begin_src python :tangle no
    """Implement fake checking a valid word"""
    return False, "Not implemented"
#+end_src

All right, so we have tests, let's see them fail!

#+begin_src shell :tangle no :exports both :async
make test 2>&1 || true
#+end_src

#+RESULTS:
#+begin_example
poetry run pytest
============================= test session starts ==============================
platform linux -- Python 3.9.5, pytest-6.2.5, py-1.11.0, pluggy-1.0.0 -- /home/jiby/dev/ws/short/literate_wordle/.venv/bin/python
cachedir: .pytest_cache
rootdir: /home/jiby/dev/ws/short/literate_wordle, configfile: pyproject.toml
plugins: cov-3.0.0, clarity-1.0.1
collecting ... collected 5 items

tests/test_checking_guess_valid_word.py::test_reject_long_words FAILED   [ 20%]
tests/test_checking_guess_valid_word.py::test_reject_overly_short_words FAILED [ 40%]
tests/test_checking_guess_valid_word.py::test_reject_nondict_words FAILED [ 60%]
tests/test_checking_guess_valid_word.py::test_accept_dict_words FAILED   [ 80%]
tests/test_pick_word.py::test_pick_word_ok_length PASSED                 [100%]

=================================== FAILURES ===================================
____________________________ test_reject_long_words ____________________________

    def test_reject_long_words():
        """Scenario: Reject long words"""
        # When guessing "affable"
        guess = "affable"
        is_valid, reject_reason = check_valid_word(guess)
        # Then the guess is rejected
        assert not is_valid, "Overly long guess should have been rejected"
        # And reason for rejection is "Guess too long"
>       assert reject_reason == "Guess too long"
E       assert == failed. [pytest-clarity diff shown]
E
E         LHS vs RHS shown below
E
E         Not implemented
E         Guess too long
E

tests/test_checking_guess_valid_word.py:39: AssertionError
________________________ test_reject_overly_short_words ________________________

    def test_reject_overly_short_words():
        """Scenario: Reject short words"""
        # When guessing "baby"
        guess = "baby"
        is_valid, reject_reason = check_valid_word(guess)
        # Then the guess is rejected
        assert not is_valid, "Overly short guess should have been rejected"
        # And reason for rejection is "Guess too short"
>       assert reject_reason == "Guess too short"
E       assert == failed. [pytest-clarity diff shown]
E
E         LHS vs RHS shown below
E
E         Not implemented
E         Guess too short
E

tests/test_checking_guess_valid_word.py:50: AssertionError
__________________________ test_reject_nondict_words ___________________________

    def test_reject_nondict_words():
        """Scenario: Reject fake words via dictionary"""
        # When guessing "vbpdj"
        guess = "vbpdj"
        is_valid, reject_reason = check_valid_word(guess)
        # Then the guess is rejected
        assert not is_valid, "Word not in dictionary should have been rejected"
        # And reason for rejection is "Not a word from the dictionary"
>       assert reject_reason == "Not a word from the dictionary"
E       assert == failed. [pytest-clarity diff shown]
E
E         LHS vs RHS shown below
E
E         Not implemented
E         Not a word from the dictionary
E

tests/test_checking_guess_valid_word.py:61: AssertionError
____________________________ test_accept_dict_words ____________________________

    def test_accept_dict_words():
        """Scenario: Accept five letter dictionary words"""
        # When guessing "crane"
        guess = "crane"
        is_valid, reject_reason = check_valid_word(guess)
        # Then the guess is accepted
>       assert is_valid, "Correct length word in dictionary should have been accepted"
E       AssertionError: Correct length word in dictionary should have been accepted
E       assert False

tests/test_checking_guess_valid_word.py:70: AssertionError
- generated xml file: /home/jiby/dev/ws/short/literate_wordle/test_results/results.xml -

----------- coverage: platform linux, python 3.9.5-final-0 -----------
Name                                     Stmts   Miss  Cover
------------------------------------------------------------
src/literate_wordle/__init__.py              1      0   100%
src/literate_wordle/assets/__init__.py       0      0   100%
src/literate_wordle/words.py                14      0   100%
------------------------------------------------------------
TOTAL                                       15      0   100%
Coverage HTML written to dir test_results/coverage.html
Coverage XML written to file test_results/coverage.xml

=========================== short test summary info ============================
FAILED tests/test_checking_guess_valid_word.py::test_reject_long_words - asse...
FAILED tests/test_checking_guess_valid_word.py::test_reject_overly_short_words
FAILED tests/test_checking_guess_valid_word.py::test_reject_nondict_words - a...
FAILED tests/test_checking_guess_valid_word.py::test_accept_dict_words - Asse...
========================= 4 failed, 1 passed in 0.13s ==========================
make: *** [Makefile:16: test] Error 1
#+end_example

Test failure as expected, and enjoy that 100% coverage![fn::Obviously coverage
metric is a very fuzzy number which doesn't guarantee much, but most well maintained code has a
tendency to have good coverage, because the features are well tested. It's a
correlation-metric, nothing more. In our case, we're doing TDD (test goes first
indeed) and we're pushing this even more to explicit our user requirements as
acceptance tests, it should be no surprise the coverage gets good.]

** Implementing the feature, one test at a time
Let's implement the proper feature. First, we fill a dummy function body to
check length, and test it out, seeing less tests fail as we implemented half the
feature:

#+NAME: valid-func-lenbody
#+begin_src python
"""Check wordle guess length only, no dict checks"""
answer_length = 5
guess_length = len(guess)
if guess_length < answer_length:
    return False, "Guess too short"
elif guess_length > answer_length:
    return False, "Guess too long"
return True, None  # No dictionary check
#+end_src

#+begin_src shell :tangle no :exports both :async
make test 2>&1 || true
#+end_src

#+RESULTS:
#+begin_example
poetry run pytest
============================= test session starts ==============================
platform linux -- Python 3.9.5, pytest-6.2.5, py-1.11.0, pluggy-1.0.0 -- /home/jiby/dev/ws/short/literate_wordle/.venv/bin/python
cachedir: .pytest_cache
rootdir: /home/jiby/dev/ws/short/literate_wordle, configfile: pyproject.toml
plugins: cov-3.0.0, clarity-1.0.1
collecting ... collected 5 items

tests/test_checking_guess_valid_word.py::test_reject_long_words PASSED   [ 20%]
tests/test_checking_guess_valid_word.py::test_reject_overly_short_words PASSED [ 40%]
tests/test_checking_guess_valid_word.py::test_reject_nondict_words FAILED [ 60%]
tests/test_checking_guess_valid_word.py::test_accept_dict_words PASSED   [ 80%]
tests/test_pick_word.py::test_pick_word_ok_length PASSED                 [100%]

=================================== FAILURES ===================================
__________________________ test_reject_nondict_words ___________________________

    def test_reject_nondict_words():
        """Scenario: Reject fake words via dictionary"""
        # When guessing "vbpdj"
        guess = "vbpdj"
        is_valid, reject_reason = check_valid_word(guess)
        # Then the guess is rejected
>       assert not is_valid, "Word not in dictionary should have been rejected"
E       AssertionError: Word not in dictionary should have been rejected
E       assert not True

tests/test_checking_guess_valid_word.py:59: AssertionError
- generated xml file: /home/jiby/dev/ws/short/literate_wordle/test_results/results.xml -

----------- coverage: platform linux, python 3.9.5-final-0 -----------
Name                                     Stmts   Miss  Cover
------------------------------------------------------------
src/literate_wordle/__init__.py              1      0   100%
src/literate_wordle/assets/__init__.py       0      0   100%
src/literate_wordle/words.py                19      0   100%
------------------------------------------------------------
TOTAL                                       20      0   100%
Coverage HTML written to dir test_results/coverage.html
Coverage XML written to file test_results/coverage.xml

=========================== short test summary info ============================
FAILED tests/test_checking_guess_valid_word.py::test_reject_nondict_words - A...
========================= 1 failed, 4 passed in 0.11s ==========================
make: *** [Makefile:16: test] Error 1
#+end_example

Progress! Four of five tests pass, so we now need the dictionary.


Note that in Wordle, the list of possible solutions is a subset of the word
dictionary used for guess validation. We previously loaded the answers, now we
need the larger set of accepted words. While it does mean there will be
duplicates, we're talking kilobytes, we can afford that.

We fetch the dictionary like before:

#+begin_src shell :tangle no
wget \
    --output-document "src/literate_wordle/assets/wordle_accepted_words_dict.txt" \
    "https://raw.githubusercontent.com/AllValley/WordleDictionary/6f14d2f03d01c36fe66e3ccc0929394251ab139d/wordle_complete_dictionary.txt"
#+end_src

#+RESULTS:

And compress it too

#+begin_src shell :tangle no :exports both
ANSWERS_FILE="src/literate_wordle/assets/wordle_accepted_words_dict.txt"
du -k "${ANSWERS_FILE}"
gzip "$ANSWERS_FILE"
du -k "${ANSWERS_FILE}.gz"
#+end_src

#+RESULTS:
: 92	src/literate_wordle/assets/wordle_accepted_words_dict.txt
: 36	src/literate_wordle/assets/wordle_accepted_words_dict.txt.gz

This time is more like two thirds shaved off, sweet.

We reach to add a function for decompressing, but realize we mostly wrote this
before, except for the different filename. So let's edit the previous iteration
to be more generic. One way this can be more generic is returning a =set= of
strings, instead of the previous =list=. This means we assume no ordering and
use hash addressing, rather than strict string ordering. After all, we will not
iterate through the list, as much as we want to randomly access entries, so the
=set= will provide benefits

#+NAME: choice-func-unzipdict-generic
#+CAPTION: Generic "unzip asset" function
#+begin_src python :tangle no
def get_asset_zip_as_set(asset_filename: str) -> set[str]:
    """Decompress a file in assets module into a set of words, separated by newline"""
    compressed_bytes = pkg_resources.read_binary(assets, asset_filename)
    string = gzip.decompress(compressed_bytes).decode("ascii")
    string_list = [word.strip().lower() for word in string.split("\n")]
    return set(string_list)
#+end_src

Which changes the invocation of =pick_answer_word= into:

#+NAME: choice-func-pickanswer-generic
#+CAPTION: Pick-a-word, revisited to generic asset fetching
#+begin_src python :tangle no
def pick_answer_word() -> str:
    """Pick a single word out of the dictionary of answers"""
    return choice(list(get_asset_zip_as_set("wordle_answers_dict.txt.gz")))
#+end_src

And now we can use the dictionary as a set in our =check_valid_word= function:


#+NAME: choice-func-pickanswer-generic
#+CAPTION: Pick-a-word, revisited to generic asset list
#+begin_src python :tangle no
    """Pick a single word out of the dictionary of answers"""
    return choice(
#+end_src

#+NAME: valid-func-len-dict
#+begin_src python
"""Check a wordle guess is valid: length and in dictionary"""
answer_length = 5
guess_length = len(guess)
if guess_length < answer_length:
    return False, "Guess too short"
elif guess_length > answer_length:
    return False, "Guess too long"
valid_words_dict = get_asset_zip_as_set("wordle_accepted_words_dict.txt.gz")
if guess in valid_words_dict:
    return True, None
return False, "Not a word from the dictionary"
#+end_src

And we're done! Let's run our system through =make= again, to spot test failures
but also to get linters:

#+begin_src shell :tangle no :exports both :async
make
#+end_src

#+RESULTS:
#+begin_example
poetry install
Installing dependencies from lock file

No dependencies to install or update

Installing the current project: literate_wordle (0.1.0)
pre-commit run --all --all-files
Emacs export org-mode file to static HTML................................Passed
Trim Trailing Whitespace.................................................Passed
Fix End of Files.........................................................Passed
Check for added large files..............................................Passed
Check that executables have shebangs.................(no files to check)Skipped
Check for case conflicts.................................................Passed
Check vcs permalinks.....................................................Passed
Forbid new submodules....................................................Passed
Mixed line ending........................................................Passed
Check for merge conflicts................................................Passed
Detect Private Key.......................................................Passed
Check Toml...............................................................Passed
Check Yaml...............................................................Passed
Check JSON...........................................(no files to check)Skipped
black....................................................................Passed
isort (python)...........................................................Passed
mypy.....................................................................Passed
flake8...................................................................Passed
cd docs && make html
make[1]: Entering directory '/home/jiby/dev/ws/short/literate_wordle/docs'
Running Sphinx v4.4.0
Read in collections ...
  wordle_html_export_filecopy: Initialised
  gherkin_features_foldercopy: Initialised
  gherkin_features_jinja: Initialised
Clean collections ...
  gherkin_features_foldercopy: (CopyFolderDriver) Folder deleted: /home/jiby/dev/ws/short/literate_wordle/docs/source/_collections/gherkin_features/
  gherkin_features_jinja: (JinjaDriver) Cleaning 1 jinja Based file/s ...
Executing collections ...
  wordle_html_export_filecopy: (CopyFileDriver) Copy file...
  gherkin_features_foldercopy: (CopyFolderDriver) Copy folder...
  gherkin_features_jinja: (JinjaDriver) Creating 1 file/s from Jinja template...
loading pickled environment... done
[autosummary] generating autosummary for: _collections/gherkin_feature.md, index.rst, readme.md, wordle.md, wordle_sources.md
[AutoAPI] Reading files... [ 33%] /home/jiby/dev/ws/short/literate_wordle/src/literate_wordle/__init__.py
[AutoAPI] Reading files... [ 66%] /home/jiby/dev/ws/short/literate_wordle/src/literate_wordle/words.py
[AutoAPI] Reading files... [100%] /home/jiby/dev/ws/short/literate_wordle/src/literate_wordle/assets/__init__.py

[AutoAPI] Mapping Data... [ 33%] /home/jiby/dev/ws/short/literate_wordle/src/literate_wordle/__init__.py
[AutoAPI] Mapping Data... [ 66%] /home/jiby/dev/ws/short/literate_wordle/src/literate_wordle/words.py
[AutoAPI] Mapping Data... [100%] /home/jiby/dev/ws/short/literate_wordle/src/literate_wordle/assets/__init__.py

[AutoAPI] Rendering Data... [ 33%] literate_wordle
[AutoAPI] Rendering Data... [ 66%] literate_wordle.words
[AutoAPI] Rendering Data... [100%] literate_wordle.assets

myst v0.15.2: MdParserConfig(renderer='sphinx', commonmark_only=False, enable_extensions=['dollarmath'], dmath_allow_labels=True, dmath_allow_space=True, dmath_allow_digits=True, dmath_double_inline=False, update_mathjax=True, mathjax_classes='tex2jax_process|mathjax_process|math|output_area', disable_syntax=[], url_schemes=['http', 'https', 'mailto', 'ftp'], heading_anchors=2, heading_slug_func=None, html_meta=[], footnote_transition=True, substitutions=[], sub_delimiters=['{', '}'], words_per_minute=200)
building [mo]: targets for 0 po files that are out of date
building [html]: targets for 5 source files that are out of date
updating environment: 0 added, 7 changed, 0 removed
reading sources... [ 14%] _collections/gherkin_feature
reading sources... [ 28%] autoapi/index
reading sources... [ 42%] autoapi/literate_wordle/assets/index
reading sources... [ 57%] autoapi/literate_wordle/index
reading sources... [ 71%] autoapi/literate_wordle/words/index
reading sources... [ 85%] wordle
reading sources... [100%] wordle_sources

Copying static files for sphinx-needs datatables support.../home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/datatables_loader.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/datatables.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/sphinx_needs_collapse.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/datatables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/JSZip-2.5.0/jszip.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/js/buttons.print.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/js/buttons.flash.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/js/buttons.html5.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/js/buttons.colVis.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/js/dataTables.buttons.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/js/buttons.html5.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/css/common.scss /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/css/mixins.scss /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/css/buttons.dataTables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Buttons-1.5.1/swf/flashExport.swf /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/DataTables-1.10.16/js/jquery.dataTables.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/DataTables-1.10.16/css/jquery.dataTables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/DataTables-1.10.16/images/sort_asc.png /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/DataTables-1.10.16/images/sort_desc_disabled.png /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/DataTables-1.10.16/images/sort_asc_disabled.png /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/DataTables-1.10.16/images/sort_both.png /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/DataTables-1.10.16/images/sort_desc.png /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/ColReorder-1.4.1/js/dataTables.colReorder.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/ColReorder-1.4.1/css/colReorder.dataTables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/FixedColumns-3.2.4/js/dataTables.fixedColumns.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/FixedColumns-3.2.4/css/fixedColumns.dataTables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Scroller-1.4.4/js/dataTables.scroller.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Scroller-1.4.4/css/scroller.dataTables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/FixedHeader-3.1.3/js/dataTables.fixedHeader.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/FixedHeader-3.1.3/css/fixedHeader.dataTables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Responsive-2.2.1/js/dataTables.responsive.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/Responsive-2.2.1/css/responsive.dataTables.min.css /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/pdfmake-0.1.32/pdfmake.min.js /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/libs/html/pdfmake-0.1.32/vfs_fonts.js
Copying static files for sphinx-needs custom style support...[ 25%] common.css
Copying static files for sphinx-needs custom style support...[ 50%] /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/css/modern/layouts.css
Copying static files for sphinx-needs custom style support...[ 75%] /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/css/modern/styles.css
Copying static files for sphinx-needs custom style support...[100%] /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/css/modern/modern.css

looking for now-outdated files... none found
pickling environment... done
checking consistency... /home/jiby/dev/ws/short/literate_wordle/docs/source/autoapi/index.rst: WARNING: document isn't included in any toctree
done
preparing documents... done
writing output... [ 12%] _collections/gherkin_feature
writing output... [ 25%] autoapi/index
writing output... [ 37%] autoapi/literate_wordle/assets/index
writing output... [ 50%] autoapi/literate_wordle/index
writing output... [ 62%] autoapi/literate_wordle/words/index
writing output... [ 75%] index
writing output... [ 87%] wordle
writing output... [100%] wordle_sources

/home/jiby/dev/ws/short/literate_wordle/docs/source/_collections/gherkin_feature.md:34: WARNING: Any IDs not assigned for table node
generating indices... genindex py-modindex done
highlighting module code... [ 50%] literate_wordle
highlighting module code... [100%] literate_wordle.words

writing additional pages... search done
copying images... [ 50%] /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/images/feather_svg/arrow-down-circle.svg
copying images... [100%] /home/jiby/dev/ws/short/literate_wordle/.venv/lib/python3.9/site-packages/sphinxcontrib/needs/images/feather_svg/arrow-right-circle.svg

copying static files... done
copying extra files... done
dumping search index in English (code: en)... done
dumping object inventory... done
build succeeded, 2 warnings.

The HTML pages are in build/html.
Final clean of collections ...
  wordle_html_export_filecopy: (CopyFileDriver) File deleted: /home/jiby/dev/ws/short/literate_wordle/docs/source/_collections/_static/wordle.html
  gherkin_features_foldercopy: (CopyFolderDriver) Folder deleted: /home/jiby/dev/ws/short/literate_wordle/docs/source/_collections/gherkin_features/
  gherkin_features_jinja: (JinjaDriver) Cleaning 1 jinja Based file/s ...
  gherkin_features_jinja: (JinjaDriver)   File deleted: /home/jiby/dev/ws/short/literate_wordle/docs/source/_collections/gherkin_feature.md

Checking sphinx-needs warnings
make[1]: Leaving directory '/home/jiby/dev/ws/short/literate_wordle/docs'
poetry run pytest
============================= test session starts ==============================
platform linux -- Python 3.9.5, pytest-6.2.5, py-1.11.0, pluggy-1.0.0 -- /home/jiby/dev/ws/short/literate_wordle/.venv/bin/python
cachedir: .pytest_cache
rootdir: /home/jiby/dev/ws/short/literate_wordle, configfile: pyproject.toml
plugins: cov-3.0.0, clarity-1.0.1
collecting ... collected 5 items

tests/test_checking_guess_valid_word.py::test_reject_long_words PASSED   [ 20%]
tests/test_checking_guess_valid_word.py::test_reject_overly_short_words PASSED [ 40%]
tests/test_checking_guess_valid_word.py::test_reject_nondict_words PASSED [ 60%]
tests/test_checking_guess_valid_word.py::test_accept_dict_words PASSED   [ 80%]
tests/test_pick_word.py::test_pick_word_ok_length PASSED                 [100%]

- generated xml file: /home/jiby/dev/ws/short/literate_wordle/test_results/results.xml -

----------- coverage: platform linux, python 3.9.5-final-0 -----------
Name                                     Stmts   Miss  Cover
------------------------------------------------------------
src/literate_wordle/__init__.py              1      0   100%
src/literate_wordle/assets/__init__.py       0      0   100%
src/literate_wordle/words.py                23      0   100%
------------------------------------------------------------
TOTAL                                       24      0   100%
Coverage HTML written to dir test_results/coverage.html
Coverage XML written to file test_results/coverage.xml

============================== 5 passed in 0.09s ===============================
poetry build
Building literate_wordle (0.1.0)
  - Building sdist
  - Built literate_wordle-0.1.0.tar.gz
  - Building wheel
  - Built literate_wordle-0.1.0-py3-none-any.whl
#+end_example

Tests pass, coverage stays strong, and linters are quiet, this is great!

** Performance trick

We mentioned before in footnotes that the whole dictionary would get unzipped on
every request for such an asset. Now we're validating guessed words, we may want
to be processing guesses quite quickly, certainly quicker than one would pick
words!

What we want to make all this fast, is to make the dictionary unzipping cached,
so that repeated calls to the function =get_asset_zip_as_set= don't bother with
file open and unzip. There's a handy python decorator that does the trick! Let's
add =functools.cache= on top of our slow function:


#+NAME: valid-cache-import
#+CAPTION: Import the cache function
#+begin_src python :tangle no
from functools import cache
#+end_src



#+NAME: valid-cache-decorator
#+CAPTION: Decorator to make a function use cache
#+begin_src python :tangle no
@cache
#+end_src

After rerunning our tests, we now have a (theoretically) faster function, yey!

Remember that we committed a couple of performance/optimization sins just then,
by both: optimizing prematurely (with no proof of slowness), and by doing
optimization without using profiling information to optimize, we very likely
just optimized something that isn't our bottleneck. I'm fine with that, just
wanted to showcase this cool decorator, which functions like an unbounded
memoizer. But just in case, let's see quick performance numbers of before/after:

#+NAME: valid-perf-before
#+CAPTION: Before cacheing, running 5 batches of a thousand double-dict-unzip
#+begin_src shell :exports both
poetry run python3 -m timeit -v -n 1000 --setup "from literate_wordle.words import pick_answer_word, check_valid_word" "check_valid_word(pick_answer_word())"
#+end_src

#+RESULTS:
: raw times: 2.75 sec, 2.72 sec, 2.73 sec, 2.73 sec, 2.72 sec
:
: 1000 loops, best of 5: 2.72 msec per loop

And after cacheing:

#+begin_src shell :exports results
poetry run python3 -m timeit -v -n 1000 --setup "from literate_wordle.words import pick_answer_word, check_valid_word" "check_valid_word(pick_answer_word())"
#+end_src

#+RESULTS:
: raw times: 17.1 msec, 12.8 msec, 12.6 msec, 12.8 msec, 12.4 msec
:
: 1000 loops, best of 5: 12.4 usec per loop

That's a two orders of magnitude gain for a single line of code changed.

** Tangle out all the code

Last section of this file used for internal purposes:
Code defined above is usually out of order, especially the imports. To avoid
having nonsence python files with import-feature-import-feature sequences, which
formatters would go crazy over, we define below some reordered code blocks,
using the =noweb= feature of org-mode, that tangle out into the proper files
with proper ordering and spacing.

This means we need to manually weave the code blocks, instead of just stating
they all point to the same file and rely on file top-to-bottom order, we have an
explicit code block where we template out "add this bit, now 2 lines below add
that snippet, and then...". Not ideal, but it has the added benefit of allowing
custom layout like number of lines jumped between functions, which was blocking
adoption of the formatter "black" in this repository.

First, fix words.py imports being out of order in our narrative by tangling them
via noweb to weave the part 1 imports with the part 2. This means =isort=
(import sorter) is now happy, won't thrash these python files. Also insert the
cache decorator before the assets function, and substitute the
=check_valid_word= function body with the real implementation instead of the
dummy function defined initially.

#+NAME: words-py-tangle
#+begin_src python :tangle src/literate_wordle/words.py :noweb yes

<<choice-stdlib>>
<<valid-cache-import>>
<<choice-stdlib2>>
<<valid-stdlib>>

<<choice-locallib>>


<<valid-cache-decorator>>
<<choice-func-unzipdict-generic>>


<<choice-func-pickanswer-generic>>


<<valid-func-proto>>
    <<valid-func-len-dict>>
#+end_src

Now the same thing with the tests file, which indeed /is/ in proper order
already, but would benefit from two-lines-between-tests to guarantee formatting:

#+NAME: words-py-tangle
#+begin_src python :tangle tests/test_checking_guess_valid_word.py :noweb yes

<<test-valid-import>>


<<test-valid-1>>


<<test-valid-2>>


<<test-valid-3>>


<<test-valid-4>>
<<reject-reason-none>>
#+end_src

* Calculating guessed word's score

We can pick answer words, and we can check if a guess is a valid word, now we
have everything we need to score the guess! Let's first define the overall
feature:

#+begin_src feature :tangle features/scoring_guess.feature
Feature: Scoring guesses
  As a Wordle game
  I need to tell the player how good their guess is
  In order to help them find the proper answer
#+end_src

This sounds simple, but implementing this feature is tricky, because of edge
cases like multiple identical character in the answer, which need colored
appropriately (What's the proper way to do that? We need to pin it down in
requirements!). So let's define /Gherkin Scenarios/ for that feature, to give
examples of how the feature works in practice. So we write out

#+NAME: scoring-scenario-perfect1
#+CAPTION: The winning guess scenario
#+begin_src feature :tangle no
Scenario: Perfect guess gives perfect score
  Given a wordle answer "crane"
  When scoring the guess "crane"
  Then score should be "🟩🟩🟩🟩🟩"
#+end_src

This seems easy enough, but we notice that we are making an assumption that's
not written out, which makes this feature depend on another: We're assuming the
guess is a valid word! We may want to just add another =Given=, like:

#+begin_src feature :tangle no
  Given a guess that's a valid dictionary word
#+end_src

But this isn't just a hypothesis from the current scenario, it's valid for all
scenarios of this feature. To avoid the tedious copying of that assumption, we
can use a =Gherkin Background= for the feature:

#+NAME: scoring-background
#+CAPTION: Pre-condition that applies to all the scenarios of this feature file
#+begin_src feature :tangle features/scoring_guess.feature
Background:
  Given a guess that's a valid dictionary word
#+end_src

Perfect, so now we're assuming the guess is a valid word, which means a
dependency on having implemented the previous feature, but we're not specifying
the guess word itself, which can still be scenario specific. This makes our
initial "perfect guess" scenario valid again, so we can use it

#+begin_src feature :tangle features/scoring_guess.feature :noweb yes :exports none
<<scoring-scenario-perfect1>>
#+end_src

Note that our scenario doesn't make assumption of how many attempts at Wordle
we're at, or the fact of winning or losing. This is purely a hypothetical
scenario, disjoint from the feature of actually playing a game.

If we've got the perfect answer, let's have the opposite:

#+NAME: scoring-scenario-nogood
#+CAPTION: Flunking out scenario
#+begin_src feature :tangle features/scoring_guess.feature
Scenario: No character in common
  Given a wordle answer "brave"
  When scoring the guess "skill"
  Then score should be "⬜⬜⬜⬜⬜""
#+end_src

** Can we start coding yet?
At this point, we only need to add a "🟨" scenario and we could conceivably
start the implementation work already, we have work to do!

The problem of "what to do now" is interesting, because we can continue thinking
up scenarios in Gherkin as a design exercise for a while, or we could already
start writing test code to back these claims, leading to failed tests, and then
start on implementation early to aim for green tests, only to add scenarios as
we realize that our implementation is lacking compared to the original intent of
the game.

While it's tempting to jump into code first, I believe we should pin down the
exact requirements on a "whiteboard" of sorts (in that case: Gherkin features
and scenarios), before starting to touch any code. It's easy to get tunnel
vision when writing code, getting excited about the programming problems, losing
track of what the "user" wants. We need to write down the exact user needs
first, so as to have a proper ritual during which to "switch from 'User' hat to
'Developer' hat".

#+begin_src python :tangle no :exports none
ok = "🟩"
wrong_place = "🟨"
not_there = "⬜"
#+end_src
